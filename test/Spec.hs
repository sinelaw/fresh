{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

--module Spec where

import           Test.QuickCheck

import           Data.DeriveTH
import qualified Data.Foldable as Foldable
import Data.Functor.Identity (runIdentity, Identity(..))
import           Control.Monad   (void, forM, forM_, when, unless)
import Data.String (IsString(..))
import Data.Maybe (catMaybes, isJust)
import qualified Data.Map as Map
import qualified Data.Set as Set
import Fresh.Pretty ()
import Fresh.Kind (Kind(..))
import Fresh.Types
import Fresh.Expr (ETypeAsc(..), EVarName(..), Lit(..), Expr(..), getAnnotation)
import Fresh.Infer (inferExpr, runInfer, instantiateAnnot, qresolve, equivalent, equivalentQual, equivalentPred, subsume, skolemize)
import Fresh.Unify (unify)
import Fresh.BuiltIn
import qualified Fresh.OrderedSet as OrderedSet
import           Fresh.OrderedSet (OrderedSet)
import qualified Fresh.Types as Types
import qualified Fresh.InferMonad as InferM
import Data.List (inits)

import System.Environment (getArgs, getProgName)
import Text.PrettyPrint.ANSI.Leijen (Pretty(..), vsep, indent, (<+>), (<$$>), red)

instance IsString EVarName where
    fromString = EVarName

instance IsString CompositeLabelName where
    fromString = CompositeLabelName


eithers :: Eq a => (b -> b -> Bool) -> Either a b -> Either a b -> Bool
eithers f (Right r1) (Right r2) = f r1 r2
eithers _ (Left e1) (Left e2) = e1 == e2
eithers _ _ _ = False

forgetLeft :: Either l r -> Either () r
forgetLeft (Right x) = Right x
forgetLeft (Left _) = Left ()

fromRight :: Either l r -> r
fromRight (Right x) = x
fromRight (Left _) = error "fromRight!"

constWrap :: Expr () -> Expr ()
constWrap = let_ dummy (num 0)
    where dummy = "a very long name that won't be generated by arbitrary"

letWrap :: Expr () -> Expr ()
letWrap expr = ("root" ~> expr) ~$ (num 0)

isRight :: Either a b -> Bool
isRight Right{} = True
isRight Left{}  = False

testEquivTypes :: Either l (QualType Type) -> Either l' (QualType Type) -> Bool
testEquivTypes inferred expected =
    eithers (\a b -> isRight $ equivalentQual a b) (forgetLeft inferred) (forgetLeft expected)


let_ :: EVarName -> Expr () -> Expr () -> Expr ()
let_ = ELet ()

var :: EVarName -> Expr ()
var = EVar ()

num :: Double -> Expr ()
num = ELit () . LitNum

str_ :: String -> Expr ()
str_ = ELit () . LitString

infixr 5 ~$
(~$) :: Expr () -> Expr () -> Expr ()
(~$) = EApp ()

infixr 2 ~::
(~::) :: Expr () -> QualType Type -> Expr ()
expr ~:: qual = EAsc () (ETypeAsc qual) expr

infixr 4 ~>
(~>) :: EVarName -> Expr () -> Expr ()
(~>) = ELam ()

infixr 5 ##
(##) :: Expr () -> CompositeLabelName -> Expr ()
(##) = EGetField ()


lama :: EVarName -> QualType Type -> Expr () -> Expr ()
lama v t = EALam () v (ETypeAsc t)

-- Types

forall :: GenVar () -> Type -> Type
forall gv = foralls [gv]

forallsQ :: [Pred Type] -> [GenVar ()] -> Type -> Type
forallsQ ps gvs t = Fix $ TyGen gvs (QualType ps t)

foralls :: [GenVar ()] -> Type -> Type
foralls = forallsQ []

gv :: Int -> GenVar ()
gv x = GenVar x Star ()

tv :: Int -> Type
tv x = Fix $ TyGenVar $ gv x

a, b, c, d, e, f, g :: Type
[a, b, c, d, e, f, g] = map tv [0,1,2,3,4,5,6]
a',b',c',d',e',f',g' :: GenVar ()
[a',b',c',d',e',f',g'] = map gv [0,1,2,3,4,5,6]

rv :: Int -> GenVar ()
rv x = GenVar x Composite ()
rtv :: Int -> Type
rtv x = Fix $ TyGenVar $ rv x

ra, rb, rc, rd, re, rf, rg :: Type
[ra, rb, rc, rd, re, rf, rg] = map rtv [0,1,2,3,4,5,6]
ra',rb',rc',rd',re',rf',rg' :: GenVar ()
[ra',rb',rc',rd',re',rf',rg'] = map rv [0,1,2,3,4,5,6]


record :: [(CompositeLabelName, Type)] -> Maybe Type -> Type
record fs rest = Fix tyRec ^$ (Fix $ TyComp c)
    where
        c = Types.unflattenComposite (FlatComposite (Map.fromList fs) rest)

-- Tests

wrapFooLet :: Expr () -> Expr ()
wrapFooLet x = let_ "foo" x $ var "foo"

exampleApIdNum :: Expr ()
exampleApIdNum = ("x" ~> var "x") ~$ num 2

--testClass :: Class
testClass =
    Class
    { clsId = ClassId "TestClass"
    , clsSupers = []
    , clsParam = a'
    , clsMembers = Map.empty
    , clsInstances = []
    }

idFunction :: Expr ()
idFunction = let_ "id" ("x" ~> var "x") $ var "id"

idBool :: Expr ()
idBool = lama "x" ([] ~=> _Bool) (var "x")

polyId :: Expr ()
polyId = lama "x" ([] ~=> forall a' (a ^-> a)) (var "x")

examples :: [(Expr (), Either () (QualType Type))]
examples = [ ( ELit () (LitBool False) , Right $ [] ~=> _Bool)
           , ( var "x", Left () )
           , ( ("x" ~> var "x") ~:: ([] ~=> (forall a' (a ^-> a) ^-> forall a' (a ^-> a)))
             , Right $ [] ~=> forall b' (forall a' (a ^-> a) ^-> (b ^-> b)))

           , ( idFunction              , Right $ [] ~=> forall c' (c ^-> c))
           , ( idBool                  , Right $ [] ~=> (_Bool ^-> _Bool))
           , ( exampleApIdNum          , Right $ [] ~=> _Number)
           , ( exampleApIdNum ~:: ([] ~=> _Bool), Left ())
           , ( exampleApIdNum ~:: ([] ~=> _Number), Right $ [] ~=> _Number)
             -- TODO deal with alpha equivalence, preferrably by
             -- making generalization produce ids like GHC

           , ( let_ "id" ("x" ~> (var "x" ~:: ([] ~=> _Number))) $ var "id",
               Right $ [] ~=> (_Number ^-> _Number))

           , ( let_ "id" (lama "x" ([] ~=> forall a' (a ^-> a)) (var "x")) $ var "id"
             , Right $ [] ~=> forall e' (forall b' (b ^-> b) ^-> (e ^-> e)))

           , ( let_ "id" ("x" ~> var "x") (var "id")  ~:: ([] ~=> (forall a' (a ^-> a) ^-> forall a' (a ^-> a)))
             , Right $ [] ~=> (forall a' (a ^-> a) ^-> forall a' (a ^-> a)))

           , ( let_ "id" ("x" ~> (var "x" ~:: ([] ~=> forall d' (d ^-> d)))) $ var "id",
               Left ()) -- impredicative instantiation (eta-expansion of polymorphic arguments doens't work)

           , ( idFunction ~:: ([] ~=> forall b' (b ^-> b)),
               Right $ [] ~=> forall b' (b ^-> b))

           , ( idFunction ~:: ([] ~=> forallsQ [PredIs (clsId testClass) b] [b'] (b ^-> b)),
               Right $ [] ~=> forallsQ [PredIs (clsId testClass) b] [b'] (b ^-> b))

           , ( wrapFooLet ("y" ~> let_ "id" ("x" ~> var "y") (var "id"))
             , Right $ [] ~=> forall b' (forall d' (b ^-> d ^-> b)))

           , ( wrapFooLet ("y" ~> let_ "id" ("x" ~> var "y") (var "id"))
             , Right $ [] ~=> forall b' (forall d' (d ^-> b ^-> d)))

           , ( wrapFooLet ("y" ~> let_ "id" ("x" ~> var "y") (var "id"))
             , Right $ [] ~=> forall b' (forall a' (a ^-> b ^-> a)))

           , ( wrapFooLet ("y" ~> let_ "id" ("x" ~> var "y") (var "id"))
             , Right $ [] ~=> forall a' (forall b' (a ^-> b ^-> a)))

           , ( let_ "zero" ("x" ~> var "x" ~$ num 0) (var "zero")
             , Right $ [] ~=> forall e' ((_Number ^-> e) ^-> e))

           , ( wrapFooLet ("x" ~> "y" ~> var "x")
             , Right $ [] ~=> foralls [f', g'] (f ^-> g ^-> f))

           , ( "x" ~> var "x" ## "fieldName"
             , Right $ [] ~=> foralls [d', re'] (record [("fieldName", d)] (Just re) ^-> d))

           , ( let_ "id"
               ("x" ~>
                ((var "x" ## "fieldName") ~:: [] ~=> _Number))
               $ var "id"
             , Right $ [] ~=> foralls [rf'] (record [("fieldName", _Number)] (Just rf) ^-> _Number))

           , ( let_ "record"
               (ELit () $ LitStruct [("fieldName", num 0)])
               $ (var "record")
             , Right $ [] ~=> (record [("fieldName", _Number)] Nothing))

           , ( let_ "record"
               (ELit () $ LitStruct [("fieldA", num 0), ("fieldB", str_ "bla")])
               $ (var "record")
             , Right $ [] ~=> (record [("fieldA", _Number), ("fieldB", _String)] Nothing))

           , ( let_ "record"
               (ELit () $ LitStruct [("polyField", idFunction ~:: ([] ~=> forall b' (b ^-> b)))])
               $ (var "record")
             , Right $ [] ~=> (record [("polyField", forall a' $ a ^-> a)] Nothing))

           , ( let_ "record"
               (ELit () $ LitStruct [("polyField", "x" ~> var "x")])
               $ (var "record")
             , Right $ [] ~=> forall a' (record [("polyField", a ^-> a)] Nothing))

           , ( let_ "record"
               (ELit () $ LitStruct [("polyField", "x" ~> var "x"), ("polyField2", "x" ~> var "x")])
               $ (var "record")
             , Right $ [] ~=> foralls [a',b'] (record [("polyField", a ^-> a), ("polyField2", b ^-> b)] Nothing))

           , ( EGetField () (ELet () (EVarName "r") (EApp () (EGetField () (EVar () (EVarName "r")) (CompositeLabelName "pbe")) (ELam () (EVarName "x") (EVar () (EVarName "x")))) (EVar () (EVarName "r"))) (CompositeLabelName "nid")
             , Left () ) -- occurs

           , ( lama "a" ([PredIs (clsId testClass) e] ~=> e) ("b" ~> ELit () (LitString "c"))
             , Right $ [] ~=> forall d' (forallsQ [PredIs (clsId testClass) e] [e'] e ^-> (d ^-> _String)) )

           , ( lama "a" ([PredIs (clsId testClass) e] ~=> (forall f' f)) ("b" ~>  (ELit () (LitString "c")))
             , Right $ [] ~=> forall d' ((forallsQ [PredIs (clsId testClass) e] [e', f'] f) ^-> (d ^-> _String)) )

           -- (\o -> let y = (\f -> o 464.5855195404157) in "bla")
           , ( "o" ~> (let_ "y" ("f" ~> (var "o" ~$ num 123)) (str_ "bla"))
             , Right $ [] ~=> forall a' ((_Number ^-> a) ^-> _String))

           ]

-- ----------------------------------------------------------------------

-- instance Arbitrary (t (Fix t)) => Arbitrary (Fix t) where
--     arbitrary = Fix <$> arbitrary

instance Arbitrary g => Arbitrary (GenVar g) where
    arbitrary = GenVar <$> (getPositive <$> arbitrary) <*> arbitrary <*> arbitrary
    shrink (GenVar i k x) = GenVar <$> shrink i <*> shrink k <*> shrink x

derive makeArbitrary ''Level

instance Arbitrary Id where
    arbitrary = oneof (map (pure . Id) ["A", "B", "C", "D", "E", "F"])

instance Arbitrary ClassId where
    arbitrary = oneof (map (pure . ClassId) ["A", "B", "C", "D", "E", "F"])

instance Arbitrary Kind where
    arbitrary = oneof (map pure
                       [ Star
                       , Composite
                       , KArrow Star Star
                       , KArrow Composite Star
                       , KArrow (KArrow Star Star) Star
                       ])
    shrink (KArrow t1 t2) = [t1, t2]
    shrink _ = []

derive makeArbitrary ''TCon

arbIdentifier = take 5 <$> shuffle ['a'..'z'] >>= sublistOf

instance Arbitrary CompositeLabelName where
    arbitrary = CompositeLabelName <$> arbIdentifier

instance Arbitrary MemberName where
    arbitrary = MemberName <$> arbIdentifier

derive makeArbitrary ''Composite

genTyAp :: Gen Type
genTyAp = do
    tf <- suchThat arbitrary $
          \t -> case kind t of
                    Just KArrow{} -> True
                    _ -> False
    let (Just (KArrow kx _)) = kind tf
    tx <- (Fix . TyCon) <$> (TCon <$> arbitrary <*> pure kx)
    let res = Fix $ TyAp tf tx
    -- assertion:
    unless (isJust $ kind res) $ error $ "Wat: " ++ show res
    return res

genTyCon :: Gen TCon
genTyCon = TCon <$> arbitrary <*> arbitrary

-- genPred :: GenVar () -> Gen (Pred Type)
-- genPred gv = PredIs <$> arbitrary <*> (pure $ Fix $ TyGenVar gv)

genTyGen :: Gen Type
genTyGen = do
    t <- arbitrary :: Gen Type
    gvSet <- Types.freeGenVars t
    case OrderedSet.toList gvSet of
        [] -> pure t
        gvs -> pure $ Fix $ TyGen gvs (QualType [] t)

instance Arbitrary Type where
    arbitrary = oneof $
        [ genTyAp
        , Fix . TyCon <$> genTyCon
        , Fix . TyGenVar <$> arbitrary
        , genTyGen
--        , Fix . TyComp <$> arbitrary
        ]

    shrink (Fix (TyAp t1 t2)) = [t1, t2]
    shrink (Fix TyCon{}) = []
    shrink (Fix TyGenVar{}) = []
    shrink (Fix (TyGen gvs (QualType ps t))) = t : q' ++ pts
        where
            pts = concatMap Foldable.toList ps
            q' = do
                gvs' <- shrink gvs
                ps' <- shrink ps
                return $ Fix $ TyGen gvs' (QualType ps' t)
    shrink (Fix TyComp{}) = [] -- TODO

arbitraryPred :: (HasKind a, Arbitrary a) => a -> Gen (Pred a)
arbitraryPred t =
    oneof $
    [ PredIs <$> arbitrary <*> pure t
    , PredNoLabel <$> arbitrary <*> pure t
    ]
    where Just k = kind t

instance (Arbitrary t, HasKind t) => Arbitrary (Pred t) where
    arbitrary = arbitrary >>= arbitraryPred
    shrink (PredIs c t) = PredIs <$> shrink c <*> shrink t
    shrink (PredNoLabel l t) = PredNoLabel <$> shrink l <*> shrink t

slowShrinkList :: Arbitrary t => [t] -> [[t]]
slowShrinkList []     = []
slowShrinkList (x:xs) = [ xs ]
                        ++ [ x:xs' | xs' <- shrink xs ]
                        ++ [ x':xs | x'  <- shrink x ]

instance Arbitrary (QualType Type) where
    arbitrary = do
        t <- arbitrary :: Gen Type
        let gvs = OrderedSet.toList $ ((runIdentity $ Types.freeGenVars t) :: OrderedSet (GenVar ()))
            gvts = map (Fix . TyGenVar) gvs
        gvts' <- oneof (map pure $ inits gvts)
        ps <- mapM arbitraryPred gvts'
        return $ QualType ps t
    shrink (QualType ps t) = (QualType <$> slowShrinkList ps <*> [t]) ++ (QualType <$> [ps] <*> shrink t)

instance Arbitrary a => Arbitrary (Instance Type (Expr a)) where
    arbitrary = Instance <$> arbitrary <*> arbitrary <*> arbitrary

instance Arbitrary a => Arbitrary (Class Type (Expr a)) where
    arbitrary = do
            arbId <- arbitrary
            arbSupers <- arbitrary
            arbParam <- arbitrary
            arbMembers <- arbitrary
            --arbInstances <- arbitrary
            let arbInstances = [] -- hard to generate instances that type check with member types...
            return (Class arbId arbSupers arbParam arbMembers arbInstances)

derive makeArbitrary ''Lit

instance Arbitrary EVarName where
    arbitrary = EVarName . (:[]) <$> oneof (map return ['a'..'z'])

instance Arbitrary ETypeAsc where
    arbitrary = ETypeAsc <$> arbitrary
    shrink (ETypeAsc q) = ETypeAsc <$> shrink q

instance Arbitrary a => Arbitrary (Expr a) where
    arbitrary = oneof
        [ ELit <$> arbitrary <*> arbitrary
        , EVar <$> arbitrary <*> arbitrary
        , ELam <$> arbitrary <*> arbitrary <*> arbitrary
        , EALam <$> arbitrary <*> arbitrary <*> arbitrary <*> arbitrary
        , EApp <$> arbitrary <*> arbitrary <*> arbitrary
        , ELet <$> arbitrary <*> arbitrary <*> arbitrary <*> arbitrary
        , EAsc <$> arbitrary <*> arbitrary <*> arbitrary
        , EGetField <$> arbitrary <*> arbitrary <*> arbitrary
        , EBuiltIn <$> arbitrary <*> arbitrary <*> arbitrary
        ]
    shrink (ELit a l) = ELit <$> [a] <*> shrink l
    shrink (EVar a v) = EVar <$> [a] <*> shrink v
    shrink (ELam a v e) = e : (ELam <$> [a] <*> [v] <*> shrink e) ++ (ELam <$> [a] <*> shrink v <*> [e])
    shrink (EALam a n t e) = e : (EALam <$> [a] <*> [n] <*> shrink t <*> [e]) ++ (EALam <$> [a] <*> [n] <*> [t] <*> shrink e)
    shrink (EApp a e1 e2) = e1 : e2 : (EApp <$> [a] <*> shrink e1 <*> [e2]) ++ (EApp <$> [a] <*> [e1] <*> shrink e2)
    shrink (ELet a n e1 e2) = e1 : e2 : (ELet <$> [a] <*> [n] <*> shrink e1 <*> [e2]) ++ (ELet <$> [a] <*> [n] <*> [e1] <*> shrink e2)
    shrink (EAsc a t e) = e : (EAsc <$> [a] <*> [t] <*> shrink e) ++ (EAsc <$> [a] <*> shrink t <*> [e])
    shrink (EGetField a e n) = e : (EGetField <$> [a] <*> [e] <*> shrink n) ++ (EGetField <$> [a] <*> shrink e <*> [n])
    shrink (EBuiltIn a n t) = (EBuiltIn <$> [a] <*> [n] <*> shrink t)

prop_ordLevel :: Level -> Bool
prop_ordLevel l = [l] == Set.toList (Set.singleton l `Set.intersection` Set.singleton l)

-- This just tests the Arbitrary instance for Type: it should only
-- generate valid types (ones that have a kind)
prop_hasKind :: Type -> Bool
prop_hasKind = isJust . kind


prop_resolve :: Type -> Bool
prop_resolve t =
    case (runInfer $ InferM.resolve (Types.unresolve t)) of
        Right (Just t') -> isRight $ equivalent t t'
        _ -> False


-- TODO: Wrong
prop_skolemize :: Type -> Bool
prop_skolemize t =
    case getSkolemized t of
    Right (Just s) -> isRight $ equivalent (wrapGen t) (wrapGen s)
    _ -> False
    where
        getSkolemized x = runInfer $ skolemize (Types.unresolve x) >>= (InferM.resolve . Types.qualType . snd)
        wrapGen ty = case OrderedSet.toList $ runIdentity $ Types.freeGenVars ty of
            [] -> ty
            gvs -> Fix $ TyGen gvs (QualType [] ty)

-- prop_hasKindStar :: Type -> Bool
-- prop_hasKindStar t = Just Star == kind t

prop_constExpand :: Expr () -> Bool
prop_constExpand expr =
    case (getAnnotation <$> inferExpr (constWrap expr), getAnnotation <$> inferExpr expr) of
        (Right cres, Right res)                     -> isRight $ equivalentQual cres res
        -- Left (WrappedError _ (WrappedError _ e)) -> Left e == res
        -- _                                        -> error "Expected success or WrappedError on const-wrapped"
        (Left{}, Left{})                            -> True
        _                                           -> False

testSubsume :: Type -> Type -> Either TypeError ()
testSubsume t1 t2 = runInfer $ subsume (Types.unresolve t1) (Types.unresolve t2)

prop_selfSubsume :: Type -> Bool
prop_selfSubsume t =
    case kind t of
        Just k -> isRight $ testSubsume t t
        _ -> error "Arbitrary Type must have kind."

prop_selfSubsumeNormalized :: Type -> Bool
prop_selfSubsumeNormalized t =
    case kind t of
        Just k -> isRight $ testSubsume t (Types.normalize t)
        _ -> error "Arbitrary Type must have kind."

prop_selfEquivalence :: Type -> Bool
prop_selfEquivalence t = isRight $ equivalent t t

prop_selfEquivalenceNormalized :: Type -> Bool
prop_selfEquivalenceNormalized t = isRight $ equivalent t (Types.normalize t)

prop_selfEquivalencePred :: Pred Type -> Bool
prop_selfEquivalencePred p = isRight $ equivalentPred p p

prop_selfEquivalenceQual :: QualType Type -> Bool
prop_selfEquivalenceQual q = isRight $ equivalentQual q q

testUnify :: Type -> Type -> Either TypeError ()
testUnify t1 t2 = runInfer $ do
    (QualType ps1 ut1) <- InferM.instantiate $ Types.unresolve t1
    (QualType ps2 ut2) <- InferM.instantiate $ Types.unresolve t2
    unify ut1 ut2

prop_unifySame :: Type -> Bool
prop_unifySame t =
    case kind t of
        Just Star -> Right () == testUnify t t
        _ -> True -- don't test

shouldUnify :: Bool -> Type -> Type -> IO ()
shouldUnify b t1 t2 = do
    putStrLn $ "Unifying: " ++ show (pretty t1) ++ " with " ++ show (pretty t2) ++ " - should succeed: " ++ show b
    let res = testUnify t1 t2
    when (b == (Right () /= res)) $ error $ show $ red $ "Wrong result: " <+> (pretty res)

erecord :: [(CompositeLabelName, Type)] -> Type
erecord x = record x Nothing

rightPad :: a -> Int -> [a] -> [a]
rightPad ch n []
    | n > 0     = replicate n ch
    | otherwise = []
rightPad ch n (x:xs)
    | n > 0     = x : rightPad ch (n-1) xs
    | otherwise = (x:xs)

return []

runTests :: Int -> IO Bool
runTests testCount = $forAllProperties (quickCheckWithResult stdArgs { maxSuccess = testCount })

defaultTestCount :: Int
defaultTestCount = 5000

parseArgs :: IO Int
parseArgs = do
    args <- getArgs
    case args of
        [] -> return defaultTestCount
        [x] -> return $ read x
        _ -> do
            progName <- getProgName
            error $ show $ pretty $ "Usage:" <+> pretty progName <+> "[tests count]"

main :: IO ()
main = do
    testCount <- parseArgs
    putStrLn "Testing..."
    shouldUnify True  (erecord []) (erecord [])
    shouldUnify True  (erecord [("x", _Bool)]) (erecord [("x", _Bool)])
    shouldUnify True  (erecord [("x", _Bool)]) (forall re' $ record [] $ Just re)
    shouldUnify False (erecord [("x", _Bool)]) (erecord [("x", _Number)])
    shouldUnify False (erecord [("x", _Bool)]) (erecord [("y", _Bool)])

    shouldUnify True (record [("num", _Number)] Nothing) (forall ra' $ record [] (Just ra))
    shouldUnify True (forall ra' $ record [("num", _Number)] (Just ra)) (forall rb' $ record [("bool", _Bool)] (Just rb))
    shouldUnify False (forall ra' $ record [("num", _Number)] (Just ra)) (forall rb' $ record [("num", _Bool)] (Just rb))

    merrs <- forM examples $ \(x, t) -> do
        putStrLn "------------------------------------------------------------"
        putStr $ rightPad ' ' 40 $ show $ pretty x
        putStr " :: (inferred) "
        let x' = letWrap x
            inferredType = getAnnotation <$> inferExpr x'
            conInferredType = getAnnotation <$> inferExpr (constWrap x')
            msgTypes = vsep
                [ "Expected:" <$$> (pretty t) -- , " = " , ( t) , "\n"
                , "Expected (normalized):" <$$> pretty (Types.normalizeQual <$> t)
                , "Inferred:" <$$> (pretty inferredType) -- , " = " , ( inferredType)
                , "Inferred (normalized):" <$$> pretty (Types.normalizeQual <$> inferredType)
                , "Inferred (raw): " <$$> (pretty $ show inferredType)
                , "Constwrap-Inferred:" <$$> pretty conInferredType -- , " = " , (show inferredType) , "\n"
                , "Constwrap-Inferred (raw): " <$$> (pretty $ show conInferredType)
                ]
            errMsgInfer = Just $ pretty $ vsep
                [ "TEST FAILED!"
                , "Wrong type inferred for:" <+> pretty x
                ] <$$> (indent 4 msgTypes)
        print . pretty $ inferredType
        if (not $ testEquivTypes inferredType conInferredType)
            then return $ Just $ pretty $ vsep
                 [ "TEST FAILED!"
                 , "Type not equivalent to constwrap of itself:"
                 , pretty inferredType
                 , pretty conInferredType
                 , "When checking inferred types:"
                 , indent 4 msgTypes
                 ]
            else if ((testEquivTypes inferredType t) && (testEquivTypes conInferredType t))
                 then return Nothing
                 else return errMsgInfer

    let errs = catMaybes merrs
    unless (null errs) $
        forM_ errs (print . red)
    putStrLn "------------------------------------------------------------"
    void $ runTests testCount


-- TODO: Check this example, it fails constWrap and also infers a type
-- that shadows some genvar (e) in the ETypeAsc:
-- let t = EALam () (EVarName "a") (ETypeAsc (QualType {qualPred = [PredIs (clsId testClass) (Fix {unFix = TyGenVar {_tyGenVar = GenVar {genVarId = 4, genVarKind = Star, genVarAnnot = ()}}})],
--                                                      qualType = Fix {unFix = TyGenVar {_tyGenVar = GenVar {genVarId = 5, genVarKind = Star, genVarAnnot = ()}}}
--                                  }))
--                                  (ELam () (EVarName "b") (ELit () (LitString "c")))
-- lama "a" ([PredIs (clsId testClass) e'] ~=> ("b" ~>  (ELit () (LitString "c"))))
